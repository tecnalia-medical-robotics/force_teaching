#!/usr/bin/env python
"""
@package ibd_force_teaching
@file ibd_force_teaching_impl.py
@author Anthony Remazeilles
@brief Teaching of force magnitude during insertion by deformation

Copyright (C) {packageCopyright}
https://www.gnu.org/licenses/gpl.txt
"""

import rospy
from geometry_msgs.msg import WrenchStamped
from force_teaching_msgs.msg import TeachIbDForceFeedback, TeachIbDForceResult

# protected region user include package begin #
from copy import deepcopy
# protected region user include package end #

class IbdForceTeachingConfig(object):
    """
    set of elements accessible through dynamic reconfigure
    autogenerated: don't touch this class
    """
    def __init__(self):
        self.wrench_window = 10
        self.wrench_std = 0.1
        pass

    def __str__(self):
        msg = "Instance of IbdForceTeachingConfig class: {"
        msg += "wrench_window: {} ".format(self.wrench_window)
        msg += "wrench_std: {} ".format(self.wrench_std)
        msg += "}"
        return msg

class IbdForceTeachingData(object):
    """
    set of input / output handled through the update methods
    autogenerated: don't touch this class
    """
    def __init__(self):
        """
        Definition of the IbdForceTeachingData attributes
        """
        # input data
        self.in_wrench = WrenchStamped()
        self.in_wrench_updated = bool()
        pass

    def __str__(self):
        msg = "Instance of IbdForceTeachingData class: \n {"
        msg += "in_wrench: {} \n".format(self.in_wrench)
        msg += "in_wrench_updated: {} \n".format(self.in_wrench_updated)
        msg += "}"
        return msg

class IbdForceTeachingPassthrough(object):
    """
    set of passthrough elements slightly violating interface / implementation separation
    Autogenerated: don't touch this class
    """
    def __init__(self):
        """ Class to contain variable breaking the interface separation
        """
        self.as_learn = None
        pass

class IbdForceTeachingImplementation(object):
    """
    Class to contain Developer implementation.
    """
    def __init__(self):
        """
        Definition and initialisation of class attributes
        """
        self.passthrough = IbdForceTeachingPassthrough()

        # protected region user member variables begin #
        # internal copy of the config variables
        self.config = None
        # received messages during processing
        self.wrenches = list()
        # whether manipulation start is detected
        self.is_start_detected = False
        # iteration
        self.start_id = -1
        # whether manipulation end is detected
        self.is_end_detected = False
        # iteration
        self.end_id = -1
        # protected region user member variables end #

    def configure(self, config):
        """
        @brief configuration of the implementation
        @param      self The object
        @param      config set of configuration parameters
        @return True on success
        """
        # protected region user configure begin #
        self.config = deepcopy(config)
        # protected region user configure end #



    def update(self, data, config):
        """
        @brief { function_description }

        @param      self The object
        @param      data data handled through the ros class
        @param      config parameters handled through dyn. recon.

        @return nothing
        """
        # protected region user update begin #
        if data.in_wrench_updated:
            self.wrenches.append(data.in_wrench)
            nb_elt = len(self.wrenches)
            rospy.loginfo("Last value (): {}".format(nb_elt, data.in_wrench))
        # protected region user update end #


    def callback_learn(self, goal):
        """
        @brief callback of service learn

        @param self The object
        @param goal(TeachIbDForce) goal provided

        @return (TeachIbDForceResponse) action output
        @warning may send some feedback during the task execution
        """

        # protected region user implementation of action callback for learn begin #
        # to provide feedback during action execution
        # to send the feedback, one should use:
        # self.passthrough.as_learn.publish_feedback(feedback)
        feedback = TeachIbDForceFeedback()
        # to contain the outcome of the task at completion
        # to send the result, one should use:
        # on suceess:
        # self.passthrough.as_learn.set_succeeded(result)
        result = TeachIbDForceResult()
        # Remind that preemption request should be checked during action execution:
        # if self.passthrough.as_learn.is_preempt_requested():
        #        rospy.loginfo('Preempted action learn')
        #        self.passthrough.as_learn.set_preempted()
        #        success = False
        #        break
        rate = rospy.Rate(200)
        rospy.loginfo("Received goal: {}".format(goal))

        self.is_start_detected = goal.is_on_contact
        self.start_id = -1
        self.is_end_detected = False
        self.end_id = -1

        is_done = False
        while not is_done:
            if len(self.wrenches < self.config.wrench_window):
                continue
            # enough data for making process
            # get the last window
            # convert it into an array structure
            # compute the related std
            # look at how this was done in contact_detection
            is_std_overcome = False
            if not self.is_start_detected and is_std_overcome:
                # start detected
                self.is_start_detected = True
                # what to do with the id?
                continue
            if self.is_start_detected and not is_std_overcome:
                self.is_end_detected = True
                is_done = True

        # protected region user implementation of action callback for learn end #

    # protected region user additional functions begin #
    # protected region user additional functions end #
